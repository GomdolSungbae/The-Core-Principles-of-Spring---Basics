# 01. Spring의 탄생 배경과 역사
## 1.1. EJB (Enterprise Java Beans)

> 2000년대 초반, Java 진영의 표준 기술은 EJB (Enterprise Java Beans)

- EJB는 대규모 엔터프라이즈 애플리케이션 개발을 위한 표준 기술로, 트랜잭션 관리, 보안, 원격 호출 등을 처리하는 데 중점을 두고 있음
- 그러나 EJB는 복잡성, 높은 의존성, 기술적 한계로 인해 개발자들에게 큰 부담을 주었음 
    - 많은 규칙과 제약을 부과하며, 애플리케이션 로직을 구현하려면 EJB 제공 인터페이스를 필수적으로 구현하는 것이 필요했음
    - 특정 컨테이너나 서버에서만 실행되며, 개발자가 특정 플랫폼에 의존하게 만들어 테스트와 유지보수가 어려움
    - EJB의 ORM 기술인 HTP는 성능과 유지보수 측면에서 부족하여 실제 애플리케이션에 사용하기 어려움


## 1.2. POJO (Plain Old Java Object) 

> POJO는 EJB처럼 복잡한 규약 없이, 자바 객체만으로 고품질 애플리케이션을 개발할 수 있다는 개념에서 등장

- POJO는 단순화된 구조로 비즈니스 로직을 자유롭게 작성하고, 유연한 설계를 구현할 수 있게 해줌 
- EJB의 ORM 문제를 해결하려는 대안으로 등장한 POJO는 EJB의 과도한 의존성에서 벗어나 개발자에게 더 나은 선택지를 제공

## 1.3. 스프링 프레임워크의 탄생

- **로드 존슨 (Rod Johnson)** 은 EJB 기반 프로젝트에서의 어려움을 바탕으로 스프링 프레임워크를 개발하기 시작
- 스프링의 목표는 경량화된 개발 모델을 제공하고 EJB의 복잡성을 극복하는 것
    - DI (Dependency Injection): 객체 간 의존성을 외부에서 주입하여 객체 생성 및 관계 관리의 복잡성을 줄임
    - AOP (Aspect-Oriented Programming): 비즈니스 로직과 횡단 관심사를 분리하여 코드 중복을 줄이고 모듈화 강화


>스프링은 EJB의 복잡한 구조를 벗어나 간단하고 유연한 솔루션을 제공하여 엔터프라이즈 애플리케이션 개발에 새로운 방향을 제시하였다. 


## 1.4. JPA (Java Persistence API)의 등장

> JPA는 EJB의 복잡한 ORM 기술을 대체하며 데이터베이스와의 상호작용을 직관적이고 효율적으로 처리할 수 있도록 해주는 기술

- 스프링은 JPA와 통합하여 트랜잭션 관리, ORM을 쉽게 사용할 수 있는 환경을 제공
    - 개발자가 트랜잭션 코드를 작성하지 않고도 선언적으로 관리할 수 있도록 지원
    - JPA와 스프링의 통합으로 인해 분산 환경에서도 효율적으로 ORM을 사용 가능


## 1.5. 스프링 프레임워크의 영향

- 스프링은 EJB의 복잡성 문제를 해결하고, 고품질의 확장 가능하며 유지보수 가능한 애플리케이션을 개발할 수 있도록 지원
- 모듈화된 아키텍처와 유연한 설계를 통해 다양한 산업 분야에서 널리 사용
- **스프링 부트 (Spring Boot)** 와 **스프링 클라우드 (Spring Cloud)** 는 클라우드 기반 분산 시스템 개발을 쉽게 만들었으며, 마이크로서비스 아키텍처를 지원
- 경량화된 설계는 대규모 시스템에서 높은 성능을 제공하고, 테스트 용이성 및 확장성을 향상시킴

<br />

# 02.  스프링이란?
> 스프링은 여러 기술을 포함한 프레임워크이자 생태계로, 여러 구성 요소가 결합하여 강력한 애플리케이션을 개발할 수 있도록 지원한다. 

스프링이라는 용어는 문맥에 따라 다르게 사용될 수 있다. 

1. 스프링 DI 컨테이너 기술
2. 스프링 프레임워크
3. 스프링 생태계


## 2.1. 스프링 생태계를 구성하는 대표적인 기술

<img width="794" alt="image" src="https://github.com/user-attachments/assets/b10cd77c-05ab-439f-93ff-adef87781cf7">


- Spring Framework: 스프링의 핵심이 되는 프레임워크
- Spring Boot: 스프링 애플리케이션을 더 쉽게 설정하고 실행할 수 있게 해주는 도구
- Spring Data: 데이터베이스와의 상호작용을 쉽게 처리하는 기술
- Spring Security: 애플리케이션의 보안을 관리하는 기술
- Spring Session: 세션 관리를 간편하게 처리하는 기술
- Spring WebFlux: 비동기 방식의 웹 애플리케이션을 개발할 수 있도록 도와주는 기술

## 2.2. 스프링 프레임워크의 주요 기술
스프링 프레임워크는 크게 여러 가지 중요한 기술들을 포함하고 있다. 이 기술들은 애플리케이션 개발의 핵심을 이루는 부분으로, 다양한 기능을 제공한다. 

- 핵심 기술: 스프링 DI 컨테이너, AOP 등
- 웹 기술: 스프링 MVC, WebFlux 등
- 데이터 접근 기술: 트랜잭션, JDBC, ORM, xml 지원 등

## 2.3. 스프링 부트 (Spring Boot)
> 스프링 부트는 스프링을 더 간편하게 사용할 수 있도록 돕는 도구로, 스프링 부트를 사용하면 단독 실행 가능한 스프링 애플리케이션을 쉽게 만들 수 있다. 

- Tomcat, Jetty 등의 웹 서버를 내장하고 있어 별도로 웹 서버를 설치할 필요가 없다.
- 개발자가 직접 설정하지 않아도 자동으로 필요한 설정을 제공하여 개발자가 더 쉽게 애플리케이션을 개발할 수 있도록 지원한다. 
- 특정 기능을 손쉽게 사용할 수 있도록 여러 가지 starter 종속성을 제공한다.

## 2.4. 스프링의 핵심 개념과 철학

- 스프링은 복잡한 기술일수록 단순한 핵심 개념을 가지고 있다는 철학을 바탕으로 개발되었다. 
- 많은 개발자들이 스프링의 철학에 열광한 이유는 객체지향 언어인 Java의 특성을 극대화시키는 데 초점을 맞추었기 때문이다. 

> 스프링은 좋은 객체지향 애플리케이션을 개발하기 위해 설계된 프레임워크이다. 객체 간의 의존성을 외부에서 주입받고, 비즈니스 로직과 공통 관심사를 분리하는 방식으로 유연하고 확장 가능한 애플리케이션을 개발할 수 있게 도와준다. 

<br />

# 03. 좋은 객체지향 프로그래밍이란?

## 3.1. 객체지향 프로그래밍 
> **객체지향 프로그래밍(OOP)** 은 프로그램을 명령어의 목록으로 처리하는 대신, **여러 개의 객체가 상호작용하는 시스템**으로 파악하는 프로그래밍 패러다임이다. 객체는 독립적인 실체로서 데이터를 처리하고, 다른 객체와 메시지를 주고받으며 동작한다. 

- 프로그램이 변경되더라도 기존 코드에 최소한의 영향을 주며, 유지보수가 용이하다.
- 대규모 소프트웨어 개발에서 객체지향 프로그래밍은 코드 재사용, 유지보수, 확장성 등을 개선하여 효율적인 개발을 가능하게 만든다. 
- 체지향 프로그래밍은 레고 블록을 조립하듯이 각 구성 요소(객체)를 독립적으로 개발하고 쉽게 교체하거나 변경할 수 있는 방식이다. 
- 각 객체는 독립적으로 동작하며 다른 객체와 상호작용할 수 있다. 

## 3.2. 객체지향의 주요 개념
#### 추상화 (Abstraction)

- 복잡한 시스템에서 중요한 부분만을 추출하여 표현한다. 
- 객체는 필요한 속성과 기능만을 외부에 노출하고, 내부 구현은 숨긴다.

#### 캡슐화 (Encapsulation)

- 객체의 데이터와 메서드를 하나의 단위로 묶어 객체 외부에서의 직접적인 접근을 제한한다. 
- 이를 통해 데이터 보호와 코드 간의 의존성을 줄일 수 있다. 

#### 상속 (Inheritance)

- 기존 클래스를 기반으로 새로운 클래스를 생성하여 코드의 재사용성을 높인다. 
- 자식 클래스는 부모 클래스의 속성과 메서드를 상속받아 기능을 확장하거나 수정할 수 있다. 


#### 다형성 (Polymorphism)

- 하나의 인터페이스로 여러 구현을 처리할 수 있는 능력
- 다형성은 역할과 구현을 분리하여 시스템을 더 단순하고 유연하게 만든다. 

## 3.3. 객체의 협력
> 객체지향 프로그래밍에서 객체는 혼자 존재하지 않는다. 객체는 서로 협력하며 동작하고, 클라이언트와 서버 역할을 가진 객체들이 상호작용한다. 

<img width="793" alt="image" src="https://github.com/user-attachments/assets/f9660fbf-3df6-448d-bdd2-96daf15a0e28">


- 클라이언트는 요청을 보내고, 서버는 요청에 대해 응답한다. 
- 수많은 객체들이 클라이언트와 서버 역할을 맡고 서로 협력하면서 시스템을 구축하게 된다. 


## 3.4. 다형성 (Polymorphism)
> 다형성은 객체지향 프로그래밍에서 역할과 구현을 분리하는 개념이다. 이를 통해 단순하고 유연하며 변경이 용이한 시스템을 구축할 수 있다. 

- 역할은 인터페이스로 정의하고, 구현은 해당 인터페이스를 구현한 클래스에서 이루어진다. 
- 클라이언트는 객체의 역할(인터페이스)만 알면 되므로, 구현이 어떻게 되어 있는지 내부 구조를 몰라도 된다. 
- 클라이언트는 구현의 변경에 영향을 받지 않으며, 객체의 구현 대상 자체를 변경해도 클라이언트 코드에는 영향을 미치지 않는다. 


### 다형성의 본질
> 다형성의 본질은 객체 간의 협력 관계에서 **인터페이스를 구현한 객체를 실행 시점에 유연하게 변경**할 수 있다는 것

- 클라이언트를 변경하지 않고도 서버의 구현 기능을 유연하게 변경할 수 있다. 
- 객체들은 역할과 구현을 분리하여 각자 맡은 역할을 수행하고, 클라이언트는 객체의 역할만 알면 된다.
- 객체 간의 관계를 유연하게 설계하면 시스템이 확장 가능하고 변경에 강한 설계로 발전할 수 있게 된다. 

### Java의 다형성
> **다형성(Polymorphism)** 은 객체지향의 중요한 개념 중 하나로, 주로 **오버라이딩(Overriding)** 을 통해 구현된다. 

- 오버라이딩은 자바의 기본 문법 중 하나로, 상속 관계에서 부모 클래스의 메서드를 자식 클래스에서 재정의하여 사용할 수 있다. 
- 다형성 덕분에 인터페이스를 구현한 객체는 실행 시점에 유연하게 변경될 수 있다. 
    - 즉 클라이언트 코드가 객체의 구현에 의존하지 않고 **역할(인터페이스)** 만을 알게 된다.
- 클래스 상속 관계에서도 부모 클래스의 메서드를 자식 클래스에서 오버라이딩하여 동작을 변경하거나 확장할 수 있다.

## 3.5. 역할과 구현을 분리
역할과 구현을 분리하는 것은 객체지향 프로그래밍에서 매우 중요한 개념이다. 

- 실세계에서 우리는 역할과 구현을 분리해서 이해할 수 있다. 
    - 예를 들어, 배우는 연기하는 역할을 맡고 있지만 실제 연기를 하는 방법은 달라질 수 있다. 
- 객체지향에서는 이와 비슷하게, **역할(인터페이스)** 은 고정되어 있지만 그 역할을 수행하는 구현 클래스는 유연하게 변경될 수 있다. 

### 역할과 구현을 분리했을 때 얻을 수 있는 장점

- 클라이언트는 역할만 알면 되므로, 서버 구현이 변경되어도 영향을 받지 않는다. 
- 새로운 기능이 필요할 때 기존 코드를 변경하지 않고 새로운 구현을 추가할 수 있다. 
- 역할만 정의하고 구현은 자유롭게 변경할 수 있기 때문에 시스템 확장 시 클라이언트 코드에 영향을 주지 않는다. 

>  인터페이스를 안정적으로 설계하는 것이 매우 중요하다. 역할을 정의하는 인터페이스가 잘못 설계되면 클라이언트와 서버 모두에 큰 변경이 발생할 수 있기 때문이다. 

### 역할과 구현을 분리하는 것의 한계
역할과 구현을 분리하는 데에도 한계가 존재한다. 역할 자체가 변경되면 클라이언트와 서버 모두에 큰 변경이 발생한다. 예를 들어 자동차를 비행기로 변경해야 한다면 자동차라는 역할이 변경되므로 클라이언트와 서버 모두 큰 변경을 겪게 된다. 

USB 인터페이스가 변경된다면 기존 USB 장치와의 호환성 문제가 발생할 수 있다. 따라서 역할을 정의하는 인터페이스는 매우 신중하게 설계해야 하며, 가능하면 변경을 최소화하도록 해야 한다. 


# 04. 좋은 객체 지향 설계의 5가지 원칙 (SOLID)
SOLID는 클린 코드의 아버지 로버트 마틴(Robert Martin)에게서 유래한, **객체 지향 설계를 개선하기 위한 5가지 핵심 원칙**

## 4.1. SRP (단일 책임 원칙)
> 클래스는 하나의 책임만 가져야 한다.

`책임` 이란 변경의 이유를 의미한다. 
- 한 클래스가 여러 책임을 지니면 하나의 책임 변경이 다른 책임에 영향을 미쳐 수정이 어렵고 코드 유지보수가 힘들어진다. 
- 변경이 발생할 때 파급 효과를 최소화하려면 클래스가 하나의 책임만 가져야 한다. 

## 4.2. OCP (개방-폐쇄 원칙, Open/Closed Principle)
> 소프트웨어 요소는 확장에는 열려 있어야 하고, 수정에는 닫혀 있어야 한다.

- 이미 존재하는 코드를 수정하지 않고도 새로운 기능을 추가할 수 있어야 한다. 
- 이는 다형성을 통해 구현할 수 있으며, 기존 코드에 영향을 주지 않고 새로운 기능을 추가할 수 있게 해준다. 
- 기존 시스템의 기능을 확장하기 위해 새로운 클래스를 만들고 기존 코드에 있는 인터페이스를 통해 새로운 기능을 추가하면, 기존 코드를 변경하지 않고도 확장이 가능하다. 

### OCP의 문제점
만약 `MemberService` 클래스에서 직접 구현 클래스를 선택하여 객체를 생성한다면 OCP를 지킬 수 없다. 

```java
public class MemberService {
    MemberRepository m = new MemoryMemberRepository(); // 기존 코드
    MemberRepository m = new JdbcMemberRepository(); // 변경 코드
}
```
이 경우 클라이언트 코드가 변경되는 문제를 해결하려면 객체 생성과 의존성 관계를 별도의 설정 객체나 컨테이너에 맡겨야 한다. 

## 4.3. LSP (리스코프 치환 원칙)
> 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 대체할 수 있어야 한다.

- 하위 클래스는 부모 클래스의 기능을 완전히 구현해야 하며, 이를 위반할 경우 다형성의 신뢰성을 잃게 된다. 
- 부모 타입의 객체를 사용할 수 있는 곳에 자식 타입의 객체를 사용해도 동작이 정상이어야 한다.
- 예) 자동차 인터페이스에서 엑셀 버튼을 누르면 차가 앞으로 가야 한다. 만약 하위 클래스에서 엑셀 버튼을 누르면 차가 뒤로 가도록 구현했다면, 이는 LSP를 위반한 것

## 4.4. ISP (인터페이스 분리 원칙)
> 클라이언트는 자신이 사용하지 않는 인터페이스에 의존하지 않아야 한다.

- 하나의 범용 인터페이스보다 여러 개의 특화된 인터페이스가 나은 경우가 많다. 
    - 클라이언트는 자신이 필요로 하는 기능만을 제공하는 인터페이스에 의존하게 해야 한다. 
    - 클라이언트가 불필요한 기능에 의존하는 것을 방지하고 변경에 대한 영향을 최소화할 수 있다.
    - 예) 자동차 인터페이스를 운전 인터페이스와 정비 인터페이스로 나누면, 운전자는 자신이 필요한 운전 기능만을, 정비사는 정비 기능만을 사용하게 되어, 한쪽의 변화가 다른 쪽에 영향을 미치지 않게 된다.

## 4.5. DIP (의존관계 역전 원칙)
> 상위 모듈은 하위 모듈에 의존해서는 안 되고, 추상화된 인터페이스에 의존해야 한다.

- 구현 클래스에 의존하지 말고 인터페이스나 추상 클래스에 의존하도록 해야 한다.
    -  이를 통해 객체의 구현을 변경할 때 클라이언트 코드가 영향을 받지 않도록 하고, 유연하게 확장 가능한 시스템을 구축할 수 있다.
    
위에서 다룬 MemberService 클래스가 MemoryMemberRepository나 JdbcMemberRepository와 같은 구체적인 구현에 의존하면 DIP를 위반한 것이다. 대신 MemberRepository라는 인터페이스에 의존하여, 실제 구현을 변경하더라도 클라이언트 코드를 수정하지 않도록 해야 한다. 

```java
MemberRepository m = new MemoryMemberRepository(); 
MemberRepository m = new JdbcMemberRepository(); 
```

> 객체 지향 설계에서 다형성은 가장 중요한 핵심 개념이다. 다형성을 통해 객체 간의 협력이 유연하고 확장 가능하게 이루어진다. 다형성만으로는 OCP와 DIP를 지키는 것이 어렵지만, 이들을 구현하기 위해서는 다형성을 적극적으로 활용해야 한다. 

<br />

# 05. 스프링과 객체 지향 설계
**스프링(Spring Framework)** 은 객체 지향 설계를 실현하기 위한 강력한 도구로, DI, AOP, 트랜잭션 관리 등 다양한 기능을 제공한다. 스프링 프레임워크는 SOLID 원칙을 지원하고 다형성, 유연성, 확장성을 강화하여 좋은 객체지향 애플리케이션을 개발할 수 있도록 도와준다. 

## 5.1. 의존성 주입 (DI)
스프링의 가장 중요한 개념 중 하나는 **의존성 주입(DI)** 이다. 이는객체 간의 의존 관계를 코드에서 명시적으로 설정하는 것이 아니라, 스프링 컨테이너가 자동으로 의존 객체를 주입하는 방식을 말한다. 

- 의존성 주입은 **DIP(의존 관계 역전 원칙)** 을 실현하는 방법 중 하나이다. 
    - DIP: 상위 모듈은 하위 모듈에 의존하면 안 되고, 추상화에 의존해야 한다.
    - DIP 적용 방법: 스프링에서는 의존성 주입을 통해 구체적인 구현체에 의존하지 않고, 인터페이스나 추상 클래스에 의존하도록 설계할 수 있다. 

## 5.2. 다형성과 스프링
다형성의 핵심은 하나의 객체가 여러 형태로 동작할 수 있게 하는 것이다. 스프링은 다형성을 지원하여 객체를 유연하게 교체하고 확장할 수 있다.

- 스프링에서 **의존성 주입**을 통해 인터페이스를 구현한 다양한 객체를 주입받을 수 있다. 
- 클라이언트 코드에서는 인터페이스에만 의존하고, 실제 구현체가 무엇인지는 스프링 컨테이너가 결정한다. 

## 5.3. AOP와 객체 지향 설계
AOP는 비즈니스 로직과 관심사의 분리를 통해 코드의 재사용성과 유지보수성을 높이는 것을 의미한다. 스프링 AOP는 주로 로깅, 보안, 트랜잭션 관리 등을 핵심 로직과 분리하여 적용한다. 

- 프로그램의 핵심 로직에 영향을 주지 않고 공통적인 기능을 추가하는 방식으로 **SRP(단일 책임 원칙)** 을 잘 따른다.


## 정리
- 객체 지향 설계의 5가지 원칙(SOLID)은 각 원칙이 상호 보완적이며 시스템의 유연성과 유지보수성을 높이는 데 중요한 역할을 한다. 
- 다형성만으로는 충분하지 않으며, OCP, DIP와 같은 원칙을 잘 결합하여 시스템을 설계해야 한다.
- 스프링은 이들 원칙을 실제로 구현할 수 있도록 돕는 도구로, DI를 활용해 객체 간 의존성을 잘 관리하고 확장 가능하며 유연한 시스템을 구현할 수 있다. 