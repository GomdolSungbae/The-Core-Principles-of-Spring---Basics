# 01. 자바 진영의 추운 겨울과 스프링의 탄생
## 1.1. EJB (Enterprise Java Beans)

> 2000년대 초반, Java 진영의 표준 기술은 EJB (Enterprise Java Beans)
- 스프링, JPA등을 합쳐논 종합선물세트
- 금융권, 아키텍트 분들이 굉장히 많이 사용했음
- 기술영업을 EJB로 많이 했음
- 컨테이너 기술, 설정에 의한 트랜잭션 관리, 분산기술, 계층마다 분산 서버를 구축 등의 고급 기술들이 제공되었음
- `EJB`는 `Entity Bean` 이라는 ORM도 보유하고 있었음
  - ORM : Java 객체를 DB에 편하게 저장하고 꺼내옴(쿼리 없이)
### 단점
1. 매우 비쌌음 (수천만원의 초고가)
2. 복잡하고, 진짜 어렵고, 느림, EJB에 의존적으로 개발, 인터페이스를 모두 구현 해야함, 코드도 지저분해지고 라이프사이클을 알기도 어려움
3. 분산기술이기 때문에 네트워크와 통신해야 해서 느림
4. 컨테이너 하나 띄우는데도 시간이 매우 오래걸림
5. Entity Bean은 기술 수준이 매우 낮았음

## POJO (Plain Old Java Object)
오래된 방식의 간단한 Java Object를 쓰는 것으로 돌아가자


## Spring
- EJB 컨테이너 대체
- 단순함의 승리
- 현재 사실상 표준 기술

## Hibernate
- EJB Entity Bean 기술을 대체
- JPA(Java Persistence API) 새로운 표준 정의
- EJB에서 Hibernate를 만든 개발자를 데려가서 거의 똑같은 기술인 JPA를 만듦
- JPA는 표준 인터페이스로 Hibernate, EclipseLink 등의 구현체가 있다
- 그러나 구현체로는 Hibernate가 80% 이상의 점유율
- 실무 + 표준 => JPA

## Spring의 역사
Rod Johnson이 EJB의 문제점을 지적, EJB가 없어도 고품질의 확장가능한 애플리케이션을 개발할 수 있음을 30,000라인 정도의 예제 코드로 풀어냄
지금 스프링의 핵심 기념, 기반 코드가 다 들어가있음 -> 
- BeanFactory, ApplicationContext, POJO, 제어의 역전, 의존관계 주입 등

- 2014년 SpringBoot 출시 (스프링의 복잡한 설정들을 자동으로 구성, 서버 내장)

# 스프링이란?
## 스프링 생태계
- 필수 : 스프링 프레임워크, 스프링 부트
- 선택 : 스프링 데이터(Spring Data JPA), 스프링 세션, 스프링 시큐리티, 스프링 Rest Docs, 스프링 배치, 스프링 클라우드

## 스프링 프레임워크
> 주요 개념은 핵심 기술에 해당한다.
- 핵심 기술 : 스프링 DI 컨테이너, AOP, 이벤트, 기타
- 웹 기술 : 스프링 MVC, 스프링 WebFlux
- 데이터 접근 기술 : 트랜잭션, JDBC, ORM 지원, XML 지원
- 기술 통합 : 캐시, 이메일, 원격접근, 스케줄링
- 테스트 : 스프링 기반 테스트 지원
- 언어 : 코틀린, 루비
- 최근에는 스프링 부트를 이용해 스프링 프레임워크의 기술들을 편리하게 사용

### 스프링 부트
> 스프링을 편리하게 사용할 수 있도록 지원하며, 최근에는 기본으로 사용함
- 단독으로 사용할 수 있는 스프링 애플리케이션을 쉽게 생성
- Tomcat같은 웹 서버를 내장해 별도로 웹 서버를 설치할 필요가 없음
- 손쉬운 빌드 구성을 위한 starter 종속성 제공
- 스프링과 3rd party 라이브러리 자동 구성
- 메트릭, 상태확인, 외부 구성 같은 프로덕션 준비 기능 제공 (모니터링)
- 관례에 의한 간결한 설정

## 스프링 단어의 의미
문맥에 따라 여러 뜻으로 사용될 수 있다.
- 스프링 DI 컨테이너 기술
- 스프링 프레임워크
- 스프링 부트, 스프링 프레임워크 등을 모두 포함한 스프링 생테계

# 스프링의 핵심 개념
> 스프링은 좋은 객체지향 어플리케이션을 개발할 수 있도록 도와주는 프레임워크 (DI, IOC 컨테이너)
- 스프링은 자바 언어 기반의 프레임워크
- 자바 언어의 가장 큰 특징 : 객체지향언어
(EJB는 EJB에 의존적으로 개발을 해야하기 때문에 객체지향이 가진 좋은 장점들을 모두 잃어버림)

# 좋은 객체 지향 프로그래밍
## 객체 지향
> **객체 지향 프로그래밍**은 컴퓨터 프로그램을 명령어의 목록으로 보는 시각에서 벗어나 여러 개의 독립된 단위, 즉 "객체"들의 모임으로 파악하고자 하는 것이다.
> 각각의 객체는 메시지를 주고받고, 데이터를 처리할 수 있다.
> 이는 프로그램을 유연하고 변경이 용이하게 만들어 대규모 소프트웨어 개발에 많이 사용된다.
> 유연, 변경이 용이 -> 조립하고 갈아끼우듯이 컴포넌트를 유연하게 변경하면서 개발

### 추상화
### 캡슐화
### 상속
### 다형성
> 역할과 구현을 분리, 즉 클라이언트에 영향을 주지 않고 새로운 기능을 제공할 수 있음
- 운전자-자동차 : 운전자는 자동차를 K3, 아반떼, 테슽라로 바꿔도 모두 운전할 수 있음
  - 운전자는 자동자 인터페이스에만 의존하는 것(역할에만 의존하는 것)
- 공연 무대 : 배우는 대체 가능 , 역할과 구현 분리, 변경 가능한 대체 가능성

## 역할과 구현을 분리
> 역할과 구현을 분리하면 단순하고 유연하게 변경이 용이해지며, 클라이언트에 영향을 주지 않으면서도 확장 가능한 설계가 가능함
- 장점
  - 클라이언트는 대상의 역할(인터페이스)만 알면 된다.
  - 클라이언트는 구현 대상의 내부 구조를 몰라도 된다.
  - 클라이언트는 대상의 내부 구조가 변경되어도 영향을 받지 않는다.
  - 클라이언트는 대상 자체를 변경해도 영향을 받지 않는다.
 
## 객체의 협력이라는 관계부터 생각

> 수 많은 객체 클라이언트와 객체 서버는 서로 협력 관계를 가진다.
- 클라이언트 : 요청
- 서버 : 응답

<img width="906" alt="image" src="https://github.com/user-attachments/assets/6d8d533e-2da5-4eb4-811a-4088dcb87a32">


## 자바에서의 다형성
> 역할 : 인터페이스

> 구현 : 인터페이스를 구현한 클래스, 구현 객체
- 객체를 설계할 때 역할과 구현을 명확히 분리
- 객체 설계시 역할(인터페이스)을 먼저 부연하고, 그 역할을 수행하는 구현 객체 만들기

### 오버라이딩
- 자바에서는 오버라이딩 된 메서드가 실행
- 다형성으로 인터페이스를 구현한 객체를 실행 시점에 유연하게 변경 가능 (이게 리플렉션인가??)
- 클래스 상속 관계도 다형성, 오버라이딩 적용 가능

![image](https://github.com/user-attachments/assets/14df1342-0061-4cb3-a802-258bf475d9c2)

### 다형성의 본질
> 클라이언트를 변경하지 않고, 서버의 구현 기능을 유연하게 변경
- 인터페이스를 구현한 객체 인스턴스를 실행 시점에 유연하게 변경

## 스프링과 객체 지향
- 스프링은 다형성을 극대화하여 이용할 수 있게 도와줌
- 스프링의 제어의 역전(IoC), 의존관계 주입(DI)은 다형성을 활용하여 역할과 구현을 편리하게 다룰 수 있도록 지원

# 좋은 객체지향 설계의 5가지 원칙, SOLID
> 클린코드로 유명한 로버트 마틴이 좋은 객체 지향 설계의 5가지 원칙을 정리

## SRP(Single responsibility principle) 단일 책임 원칙

> 하나의 클래스는 하나의 책임만 가져야 하낟.
- 하나의 책임이라는 것의 중요한 기준은 `변경`이다.
변경이 있을 때 파급 효과가 적으면 단일 책임 원칙ㅇ르 잘 따른 것이라고 볼 수 있다.
너무 범위를 작게 해도, 크게 해도 책임이 너무 크기 때문에 적절한 책임을 가질 수 있도록 적절한 크기로 잘 나누어야 한다.

## ⭐️ OCP(Open/closed principle) 개방 폐쇄 원칙
> 소프트웨어 요소는 확장에는 열려 있으나, 변경에는 닫혀 있어야 한다.
> 즉, **다형성**을 활용한다.
> 인터페이스를 구현한 새로운 클래스를 하나 만들어 새로운 기능을 구현한다.

예를 들어, 다음과 같은 MemberService 코드에서 구현 클래스를 직접 선택하는 것은 **구현 객체를 변경하기 위해 클라이언트 코드를 직접 변경하고 있으므로, OCP를 위반**한다고 볼 수 있다.
OCP 위반 = 클라이언트를 변경
``` java
// MemberRepository m = new MemoryMemberRepository(); //기존 코드
• MemberRepository m = new JdbcMemberRepository(); //변경 코드
```

> 따라서 이러한 문제를 극복하기 위해 **객체를 생성하고 연관관계를 맺어주는 별도의 조립, 설정자**가 필요
> 
> => **스프링**


## LSP(Liskov substitution principle) 리스코프 치환 원칙
> 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.
> 다형성에서 하위 클래스는 인터페이스의 규약을 다 지켜야 한다. 단순히 컴파일에 성공하는 것을 넘어서 다형성을 지원하기 위한 원칙, 인터페이스를 구현한 구현체를 믿고 사용하기 위해서

ex) 자동차 인터페이스의 엑셀은 앞으로 가는 기능이어야 한다. 뒤로 가게 구현하면 LSP 위반

## ISP(Interface segregation principle) 인터페이스 분리 원칙
> 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.
- 인터페이스가 명확해지고 대체 가능성이 높아진다.
- 자동차 인터페이스 -> 운전 인터페이스, 정비 인터페이스로 분리
- 사용자 클라이언트 -> 운전자 클라이언트, 정비사 클라이언트로 분리

## ⭐️ DIP(Dependency inversion principle) 의존관계 역전 원칙
> 추상화에 의존해야지 구체화에 의존하면 안된다.
> 즉, 클라이언트가 구현 클래스가 아닌 인터페이스를 바라봐야 한다.
앞의 OCP에서 설명한 MemberService는 인터페이스에 의존하지만, 구현 클래스도 동시에 의존하고 있다. -> **DIP를 위반**
``` java
// MemberRepository m = new MemoryMemberRepository(); //기존 코드
• MemberRepository m = new JdbcMemberRepository(); //변경 코드
```

> 객체지향의 핵심은 다형성이지만, **다형성만으로는 OCP, DIP를 지킬 수 없다.** 위에서 본 것과 같이, 구현 객체를 변경할 때 클라이언트 코드도 함께 변경하게 된다.
>
> => 스프링이 탄생한 배경

# 객체 지향 설계와 스프링
> 스프링은 DI, DI컨테이너를 통해 클라이언트의 코드 변경 없이 기능을 확장할 수 있어 다형성 + OCP, DIP를 지킬 수 있다.
- **DI(Dependency Injection)** : 의존 관계, 의존성 주입
- **DI 컨테이너**
